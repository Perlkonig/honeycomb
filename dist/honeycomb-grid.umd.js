(function(c,a){typeof exports=="object"&&typeof module<"u"?a(exports):typeof define=="function"&&define.amd?define(["exports"],a):(c=typeof globalThis<"u"?globalThis:c||self,a(c.Honeycomb={}))})(this,function(c){"use strict";const a=e=>Number.isFinite(e)&&!Number.isNaN(e),N=e=>typeof e=="object"&&e!==null,nt=e=>N(e)&&a(e.q)&&a(e.r),st=e=>typeof e=="function",O=e=>N(e)&&a(e.col)&&a(e.row),Q=e=>N(e)&&a(e.x)&&a(e.y),E=e=>Array.isArray(e)&&a(e[0])&&a(e[1]),R=(e,t)=>t+e*(t&1)>>1;function ot(e,t){return(e%t+t)%t}const it=(e,t)=>ot(e+t,8),I=([e,t,r=-e-t])=>({q:e,r:t,s:r});function b({q:e,r:t,s:r}){const n=a(e),s=a(t),o=a(r);if(n&&s&&o)return{q:e,r:t,s:r};if(n&&s)return{q:e,r:t,s:-e-t};if(n&&o)return{q:e,r:-e-r,s:r};if(s&&o)return{q:-t-r,r:t,s:r};throw new TypeError(`Can't determine three cube coordinates from less than two coordinates. Received: { q: ${e}, r: ${t}, s: ${r} }.`)}var d=(e=>(e.FLAT="FLAT",e.POINTY="POINTY",e))(d||{});function z(e,t){if(N(e)&&e.xRadius>0&&e.yRadius>0)return e;if(N(e)&&e.width>0&&e.height>0){const{width:r,height:n}=e;return t===d.POINTY?{xRadius:r/Math.sqrt(3),yRadius:n/2}:{xRadius:r/2,yRadius:n/Math.sqrt(3)}}if(e>0)return{xRadius:e,yRadius:e};throw new TypeError(`Invalid dimensions: ${JSON.stringify(e)}. Dimensions must be expressed as an Ellipse ({ xRadius: number, yRadius: number }), a Rectangle ({ width: number, height: number }) or a number.`)}function U(e,t){if(Q(e))return e;if(!t)throw new TypeError(`Supply a bounding box ({ width: number, height: number }). Received: ${JSON.stringify(t)}`);if(e==="topLeft")return{x:t.width*-.5,y:t.height*-.5};throw new TypeError(`Invalid origin: ${JSON.stringify(e)}. Origin must be expressed as a Point ({ x: number, y: number }) or the string 'topLeft'.`)}class ${get center(){const{width:t,height:r,x:n,y:s}=this;return{x:t/2-n,y:r/2-s}}get col(){return P(this).col}get corners(){const{orientation:t,width:r,height:n,x:s,y:o}=this;return t===d.POINTY?ct(r,n,s,o):ut(r,n,s,o)}get dimensions(){return S.dimensions}get height(){const{orientation:t,dimensions:{yRadius:r}}=this;return t===d.POINTY?r*2:r*Math.sqrt(3)}get isFlat(){return this.orientation===d.FLAT}get isPointy(){return this.orientation===d.POINTY}get orientation(){return S.orientation}get origin(){return S.origin}get offset(){return S.offset}get row(){return P(this).row}get width(){const{orientation:t,dimensions:{xRadius:r}}=this;return t===d.POINTY?r*Math.sqrt(3):r*2}get x(){return p(this).x}get y(){return p(this).y}get s(){return-this.q-this.r}q;r;constructor(t=[0,0]){const{q:r,r:n}=w(this,t);this.q=r,this.r=n}clone(t=this){return new this.constructor(t)}equals(t){return k(this,O(t)?B(this,t):t)}toString(){return`${this.constructor.name}(${this.q},${this.r})`}translate(t){return X(this,t)}}const S={dimensions:{xRadius:1,yRadius:1},orientation:d.POINTY,origin:{x:0,y:0},offset:-1},ct=(e,t,r,n)=>[{x:r+e*.5,y:n-t*.25},{x:r+e*.5,y:n+t*.25},{x:r,y:n+t*.5},{x:r-e*.5,y:n+t*.25},{x:r-e*.5,y:n-t*.25},{x:r,y:n-t*.5}],ut=(e,t,r,n)=>[{x:r+e*.25,y:n-t*.5},{x:r+e*.5,y:n},{x:r+e*.25,y:n+t*.5},{x:r-e*.25,y:n+t*.5},{x:r-e*.5,y:n},{x:r-e*.25,y:n-t*.5}];function Z(e){const{dimensions:t,orientation:r,origin:n,offset:s}={...S,...e};return class extends ${get dimensions(){return z(t,r)}get orientation(){return r}get origin(){return U(n,this)}get offset(){return s}}}function k(e,t){if(O(e)&&O(t))return e.col===t.col&&e.row===t.row;if(Object.hasOwn(e,"col")||Object.hasOwn(t,"col"))throw new Error(`Can't compare coordinates where one are offset coordinates. Either pass two offset coordinates or two axial/cube coordinates. Received: ${JSON.stringify(e)} and ${JSON.stringify(t)}`);const r=E(e)?I(e):e,n=E(t)?I(t):t;return r.q===n.q&&r.r===n.r}const ft=(e,t,r)=>({col:e+R(r,t),row:t}),ht=(e,t,r)=>({col:e,row:t+R(r,e)}),P=({q:e,r:t,offset:r,isPointy:n})=>n?ft(e,t,r):ht(e,t,r),p=({orientation:e,dimensions:{xRadius:t,yRadius:r},origin:{x:n,y:s},q:o,r:i})=>e===d.POINTY?{x:t*Math.sqrt(3)*(o+i/2)-n,y:r*3/2*i-s}:{x:t*3/2*o-n,y:r*Math.sqrt(3)*(i+o/2)-s},Y=(e,t,r)=>{const n=e-R(r,t),s=t,o=-n-s;return{q:n,r:s,s:o}},J=(e,t,r)=>{const n=e,s=t-R(r,e),o=-n-s;return{q:n,r:s,s:o}},B=({offset:e,isPointy:t},{col:r,row:n})=>t?Y(r,n,e):J(r,n,e),W=e=>{const{q:t,r,s:n}=b(e);let s=Math.round(t),o=Math.round(r),i=Math.round(n);const u=Math.abs(t-s),f=Math.abs(r-o),h=Math.abs(n-i);return u>f&&u>h?s=-o-i:f>h?o=-s-i:i=-s-o,{q:s,r:o,s:i}},V=({dimensions:{xRadius:e,yRadius:t},origin:r,isPointy:n},{x:s,y:o})=>(s+=r.x,o+=r.y,W(n?{q:Math.sqrt(3)*s/(3*e)-o/(3*t),r:2/3*(o/t)}:{q:2/3*(s/e),r:Math.sqrt(3)*o/(3*t)-s/(3*e)}));function w(e,t){return E(t)?I(t):O(t)?B(e,t):b(t)}function X(e,t){const{q:r,r:n,s}=b(e),{q:o,r:i,s:u}=b(t),f={q:r+o,r:n+i,s:s+u};return e instanceof $?e.clone(f):f}function A(e,t,r){const{q:n,r:s,s:o}=w(e,t),{q:i,r:u,s:f}=w(e,r);return Math.max(Math.abs(n-i),Math.abs(s-u),Math.abs(o-f))}var F=(e=>(e.CLOCKWISE="CLOCKWISE",e.COUNTERCLOCKWISE="COUNTERCLOCKWISE",e))(F||{}),l=(e=>(e[e.N=0]="N",e[e.NE=1]="NE",e[e.E=2]="E",e[e.SE=3]="SE",e[e.S=4]="S",e[e.SW=5]="SW",e[e.W=6]="W",e[e.NW=7]="NW",e))(l||{});const at=[null,{q:1,r:-1},{q:1,r:0},{q:0,r:1},null,{q:-1,r:1},{q:-1,r:0},{q:0,r:-1}],lt=[{q:0,r:-1},{q:1,r:-1},null,{q:1,r:0},{q:0,r:1},{q:-1,r:1},null,{q:-1,r:0}],gt=({offset:e,q:t,r,col:n,row:s},o)=>{if(o===l.S||o===l.N){const u=o===l.S?s+1:s-1;return Y(n,u,e)}const i=at[o];return{q:t+i.q,r:r+i.r}},dt=({offset:e,q:t,r,col:n,row:s},o)=>{if(o===l.E||o===l.W){const u=o===l.E?n+1:n-1;return J(u,s,e)}const i=lt[o];return{q:t+i.q,r:r+i.r}},C=(e,t)=>e.clone(e.isPointy?gt(e,t):dt(e,t));function x(e){return Array.isArray(e)?function(r,n){const s=[];let o=n;for(const i of e)for(const u of i(r,o))s.push(o=u);return s}:e}const mt=(...e)=>t=>e.map(t);function L(e){return qt(e)?Tt(e):yt(e)}function qt(e){return e.direction in l}function Tt({start:e,direction:t,length:r}){return function(s,o){const i=[];let f=s(e??o);!e&&o&&(f=C(f,t));for(let h=0;h<r;h++)i.push(f),f=C(f,t);return i}}function yt({start:e,stop:t}){return function(n,s){const o=[],i=n(e??s),u=D(i),f=D(w(i,t)),h=Ot(u,f),m=A(i,i,t),H=1/Math.max(m,1);let y=!e&&s?1:0;for(y;y<=m;y++){const g=W(h(H*y));o.push(n(g))}return o}}function D({q:e,r:t,s:r}){return{q:e+1e-6,r:t+1e-6,s:r+-2e-6}}function Ot(e,t){return r=>{const n=e.q*(1-r)+t.q*r,s=e.r*(1-r)+t.r*r;return{q:n,r:s}}}const bt=e=>(t,r)=>[C(t(r),e)];function _(e,t,{includeSource:r=!0}={}){return function(s,o){const i=[];for(const u of x(e)(s,o)){r&&i.push(u);for(const f of x(t)(s,u))i.push(f)}return i}}function St(e,t){return function(n,s){const{width:o,height:i,start:u,direction:f=l.E}=t?wt(e,t,n()):e,h=n(u??s),m=_(L({start:h,direction:it(f,2),length:i}),L({direction:f,length:o-1}))(n,h);return!u&&s?m.slice(1):m}}function wt(e,t,{isPointy:r,offset:n}){const{col:s,row:o}=G(e,r,n),{col:i,row:u}=G(t,r,n),f=s<i?"A":"B",h=o<u?"A":"B",m=f+h,{swapWidthHeight:H,direction:y}=Ct[m],g=Math.abs(s-i)+1,v=Math.abs(o-u)+1;return{width:H?v:g,height:H?g:v,start:e,direction:y}}function G(e,t,r){if(O(e))return e;const{q:n,r:s}=E(e)?I(e):b(e);return P({q:n,r:s,isPointy:t,offset:r})}const Ct={AA:{swapWidthHeight:!1,direction:l.E},AB:{swapWidthHeight:!0,direction:l.N},BA:{swapWidthHeight:!0,direction:l.S},BB:{swapWidthHeight:!1,direction:l.W}};function xt(e,t){return x(Array.from({length:e},()=>x(t)))}function tt(e){const{center:t,rotation:r=F.CLOCKWISE}=e;return function(s,o){const i=r.toUpperCase(),u=[];let{radius:f}=e,h;a(f)?h=s(t).translate({q:f,s:-f}):(h=s(e.start??o),f=A(h,t,h));const{q:m,r:H,s:y}=w(h,t);let g=s({q:m,r:H-f,s:y+f});if(i===F.CLOCKWISE)for(let q=0;q<6;q++)for(let M=0;M<f;M++){const{q:j,r:K}=et[q];g=s({q:g.q+j,r:g.r+K}),u.push(g)}else for(let q=5;q>=0;q--)for(let M=0;M<f;M++){const{q:j,r:K}=et[q];g=s({q:g.q-j,r:g.r-K}),u.push(g)}const v=!e.start&&o,rt=u.findIndex(q=>q.equals(h));return u.slice(rt+(v?1:0)).concat(u.slice(0,rt))}}const et=[{q:1,r:0},{q:0,r:1},{q:-1,r:1},{q:-1,r:0},{q:0,r:-1},{q:1,r:-1}];function Ht({radius:e,start:t,rotation:r}){return function(s,o){const i=s(t??o);return _(L({start:t,direction:l.N,length:e}),tt({center:i,rotation:r}))(s,o)}}class T{static fromIterable(t){const r=t[Symbol.iterator]().next().value;if(!r)throw new TypeError(`Can't create grid from empty iterable: ${JSON.stringify(t)}`);return new T(r.constructor,t)}static fromJSON({hexSettings:t,coordinates:r}){const n=Z(t);return new T(n,r.map(s=>new n(s)))}get size(){return this.#r.size}get pixelWidth(){if(this.size===0)return 0;const{isPointy:t,width:r}=this.#e,n=this.toArray(),{0:s,length:o,[o-1]:i}=t?n.sort((u,f)=>f.s-u.s||u.q-f.q):n.sort((u,f)=>u.q-f.q);return i.x-s.x+r}get pixelHeight(){if(this.size===0)return 0;const{isPointy:t,height:r}=this.#e,n=this.toArray(),{0:s,length:o,[o-1]:i}=t?n.sort((u,f)=>u.r-f.r):n.sort((u,f)=>f.s-u.s||u.r-f.r);return i.y-s.y+r}[Symbol.iterator](){return this.#r.values()}get#e(){return this.#t.prototype}#t;#r=new Map;constructor(t,r=[]){if(t instanceof T){this.#t=t.#t,this.setHexes(t);return}this.#t=t,this.setHexes(this.#s(r))}createHex(t){return new this.#t(t)}getHex(t){const r=this.createHex(t);return this.#r.get(r.toString())}hasHex(t){return this.#r.has(t.toString())}setHexes(t){for(const r of t)this.#n(r);return this}filter(t){const r=new T(this.#t);for(const n of this)t(n)&&r.#n(n);return r}map(t){const r=new T(this.#t);for(const n of this)r.#n(t(n));return r}traverse(t,{bail:r=!1}={}){const n=new T(this.#t);for(const s of this.#s(t)){const o=this.getHex(s);if(o)n.#n(o);else if(r)return n}return n}forEach(t){for(const r of this)t(r);return this}reduce(t,r){if(r===void 0){let s,o,i;for(const u of this)o=i,i=u,o&&(s=t(o,i));return s}let n=r;for(const s of this)n=t(n,s);return n}toArray(){return Array.from(this)}toJSON(){const{dimensions:t,orientation:r,origin:n,offset:s}=this.#e;return{hexSettings:{dimensions:t,orientation:r,origin:n,offset:s},coordinates:this.toArray()}}toString(){return`${this.constructor.name}(${this.size})`}pointToHex(t,{allowOutside:r=!0}={}){const n=V(this.#e,t);return r?this.createHex(n):this.getHex(n)}distance(t,r,{allowOutside:n=!0}={}){if(n)return A(this.#e,t,r);const s=this.getHex(t),o=this.getHex(r);if(!(!s||!o))return A(this.#e,s,o)}neighborOf(t,r,{allowOutside:n=!0}={}){if(n)return C(this.createHex(t),r);const s=this.getHex(t);if(!!s)return this.getHex(C(s,r))}#n(t){this.#r.set(t.toString(),t)}#s(t){return this.#o(t)?this.#i(t):Array.isArray(t)&&this.#o(t[0])?this.#i(x(t)):t}#o(t){return st(t)}#i(t){return t(this.createHex.bind(this))}}c.Direction=l,c.Grid=T,c.Hex=$,c.Orientation=d,c.Rotation=F,c.completeCube=b,c.concat=x,c.createHexDimensions=z,c.createHexOrigin=U,c.defaultHexSettings=S,c.defineHex=Z,c.distance=A,c.equals=k,c.fromCoordinates=mt,c.hexToOffset=P,c.hexToPoint=p,c.isAxial=nt,c.isOffset=O,c.isPoint=Q,c.isTuple=E,c.line=L,c.move=bt,c.neighborOf=C,c.offsetFromZero=R,c.offsetToCube=B,c.offsetToCubeFlat=J,c.offsetToCubePointy=Y,c.pointToCube=V,c.rectangle=St,c.repeat=xt,c.repeatWith=_,c.ring=tt,c.round=W,c.spiral=Ht,c.toCube=w,c.translate=X,c.tupleToCube=I,Object.defineProperties(c,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
